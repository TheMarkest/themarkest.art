<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TheMarkest.art – Glitch Image + Portrait</title>
  <meta name="description" content="Портфолио художника в стиле sci‑fi/cyberpunk, с волной, старомониторным эффектом, TextScramble, пиксельным глитч‑логотипом, фото художника и удобными карточками работ." />

  <!-- Favicons -->
  <link rel="apple-touch-icon" sizes="180x180" href="assets/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/svg+xml" href="assets/favicon/favicon.svg">
  <link rel="icon" type="image/png" sizes="96x96" href="assets/favicon/favicon-96x96.png">
  <link rel="icon" type="image/x-icon" href="assets/favicon/favicon.ico">
  <link rel="manifest" href="assets/favicon/site.webmanifest">
  <meta name="msapplication-TileColor" content="#000000">
  <meta name="theme-color" content="#000000">

  <!-- Подключаем шрифт Handjet -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Handjet" rel="stylesheet">

  <!-- Preload для фонового изображения обложки -->
  <link rel="preload" as="image" href="https://picsum.photos/1600/900?grayscale">

  <!-- Подключение внешнего файла стилей -->
  <link rel="stylesheet" href="styles.css">
  
  <!-- Убрали внешний парсер CSV -->
</head>
<body>
  <!-- HEADER -->
  <header>
    <canvas id="waveCanvas"></canvas>
    <div class="header-content">
      <div class="logo-container">
        <div class="glitch-image">
          <img src="assets/logo.svg" alt="TheMarkest.art Logo" />
        </div>
      </div>
      <nav class="nav-links">
        <a href="#cover">Обложка</a>
        <a href="#works">Портфолио</a>
        <a href="#about">О художнике</a>
        <a href="#contact">Контакты</a>
      </nav>
      <!-- Переключатель языка -->
      <div class="language-switcher">
        <div class="language-buttons">
          <button>EN</button>
          <button>RU</button>
          <button>KZ</button>
          <button>UA</button>
        </div>
        <select class="language-dropdown">
          <option value="EN">EN</option>
          <option value="RU">RU</option>
          <option value="KZ">KZ</option>
          <option value="UA">UA</option>
        </select>
      </div>
      <button class="burger">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </header>

  <!-- COVER -->
  <section id="cover">
    <div class="cover-content">
      <h2>MARK BOGDANOV</h2>
      <p>Искусство о науке.</p>
    </div>
  </section>

  <!-- MAIN CONTENT -->
  <main>
    <!-- Портфолио -->
    <section id="works">
      <div class="container">
        <h2>Портфолио</h2>
        <div class="grid" id="portfolio-container">
          <!-- Здесь будут появляться placeholder-ы, заменяемые на карточки при прокрутке -->
        </div>
      </div>
    </section>

    <!-- О художнике -->
    <section id="about">
      <div class="container">
        <h2>О художнике</h2>
        <div class="about-content">
          <div class="bio-row">
            <div class="bio">
              <h3>Биография</h3>
              <p>
                Марк Богданов — художник, работающий на стыке искусства, технологий и инженерной эстетики. В своих произведениях он исследует влияние научного прогресса на визуальные формы, сочетая современные методы производства (3D-печать, лазерную резку, цифровую обработку) с традиционными материалами.

                Родился в 1998 году в семье хореографов и вырос между Санкт-Петербургом и Одессой — двумя городами с глубокими культурными традициями. Детство и юность пришлись на переломные десятилетия цифровой революции, когда искусство и технологии начали стремительно сближаться. Это время сформировало его интерес к новым методам создания и восприятия искусства, где материальный объект все чаще сочетался с виртуальными и механическими компонентами.
                
                Получив образование в сфере оптико-электроники, он переосмыслил принципы традиционной скульптуры через призму научного знания. Вдохновляясь конструктивизмом, ретрофутуризмом и инженерным мышлением, он рассматривает искусство не только как средство самовыражения, но и как способ изучения структуры окружающего мира. Его работы исследуют, как технологии не просто изменяют художественную эстетику, но и формируют новые принципы взаимодействия человека с объектом.
              </p>
            </div>
            <div class="artist-photo">
              <!-- Используем webp копию портрета -->
              <img src="assets/portrait.webp" alt="Portrait of the Artist" loading="lazy" decoding="async" />
            </div>
          </div>
          <div class="artist-statement">
            <h3>Artist Statement</h3>
            <p>
              Я создаю скульптуры, в которых современные технологии производства встречаются с наследием инженерной
              мысли прошлого.
              Моё искусство — это поиск формы, структуры и материала, отражающих логику научного прогресса.

              В своих работах я сочетаю 3D-печать, лазерную резку, цифровую обработку и традиционные ремесленные
              техники,
              интегрируя их в единую художественную систему. Мне важно показать, как технологии формируют эстетику и
              как через них можно создавать новые визуальные смыслы, выходящие за пределы привычного восприятия.

              Я вдохновляюсь конструктивизмом, ретрофутуризмом и инженерной эстетикой, рассматривая искусство как способ
              взаимодействия с научным знанием.
            </p>
          </div>
        </div>
      </div>
    </section>

    <!-- Контакты -->
    <section id="contact">
      <div class="container">
        <h2>Контакты</h2>
        <div class="contact-buttons">
          <a class="contact-button" href="https://t.me/markestart" target="_blank">Telegram</a>
          <a class="contact-button" href="https://instagram.com/markestart" target="_blank">Instagram</a>
          <a class="contact-button" href="tel:+77051248743">Телефон</a>
          <a class="contact-button" href="mailto:markbogdanovofficial@gmail.com">Email</a>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <div class="container">
      &copy; 2025 TheMarkest.art. Все права защищены.
    </div>
  </footer>

  <!-- Модальное окно для полноэкранного просмотра медиа -->
  <div id="modal" class="modal">
    <div id="modal-content" class="modal-content">
      <div id="modal-title-bar" class="modal-title-bar">
        <span id="modal-close" class="modal-close">&#10005;</span>
        <span id="modal-title-text"></span>
      </div>
      <div id="modal-media-wrapper" class="modal-media-wrapper"></div>
    </div>
  </div>

  <!-- Все основные скрипты размещены в конце для ускорения загрузки -->

  <!-- Wave Animation (на основе времени) -->
  <script>
    const canvas = document.getElementById("waveCanvas");
    const ctx = canvas.getContext("2d");
    let width = 0, height = 0;
    let time = 0, lastWaveTime;
    let dots = [];
    const AMPLITUDE = 15, DOT_SPACING = 40, FREQ_MIN = 0.03, FREQ_MAX = 0.08;
    const LINE_WIDTH = 2, DOT_RADIUS = 4, HEADER_BG_COLOR = "rgba(85,85,85,0.8)";
    const BASELINE = 120;
    function initDots() {
      width = canvas.offsetWidth;
      height = canvas.offsetHeight;
      canvas.width = width;
      canvas.height = height;
      dots = [{ x: 0, pinned: true }];
      for (let x = DOT_SPACING; x <= width - DOT_SPACING; x += DOT_SPACING) {
        dots.push({ x, pinned: false, freq: FREQ_MIN + Math.random() * (FREQ_MAX - FREQ_MIN), phase: Math.random() * Math.PI * 2 });
      }
      dots.push({ x: width, pinned: true });
    }
    function animateWave(timestamp) {
      if (!lastWaveTime) lastWaveTime = timestamp;
      const delta = timestamp - lastWaveTime;
      lastWaveTime = timestamp;
      time += delta * 0.0012;
      ctx.clearRect(0, 0, width, height);
      const wavePoints = dots.map(dot => dot.pinned ? { x: dot.x, y: BASELINE } : { x: dot.x, y: BASELINE + AMPLITUDE * Math.sin(dot.x * dot.freq + time + dot.phase) });
      ctx.beginPath();
      ctx.moveTo(0, 0);
      wavePoints.forEach(p => ctx.lineTo(p.x, p.y));
      ctx.lineTo(width, 0);
      ctx.closePath();
      ctx.fillStyle = HEADER_BG_COLOR;
      ctx.fill();
      ctx.beginPath();
      ctx.strokeStyle = "#0ff";
      ctx.lineWidth = LINE_WIDTH;
      wavePoints.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
      ctx.stroke();
      wavePoints.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, DOT_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = "#0ff";
        ctx.fill();
      });
      requestAnimationFrame(animateWave);
    }
    let resizeTimeout;
    window.addEventListener("resize", () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(initDots, 100); });
    initDots();
    requestAnimationFrame(animateWave);
  </script>

  <!-- Функция measureCardHeight -->
  <script>
    function measureCardHeight(article) {
      const clone = article.cloneNode(true);
      clone.querySelectorAll(".scramble-text").forEach(el => {
        const txt = el.getAttribute("data-text") || el.textContent;
        el.textContent = txt;
      });
      clone.style.position = "absolute";
      clone.style.visibility = "hidden";
      clone.style.zIndex = "-9999";
      document.body.appendChild(clone);
      let h = clone.offsetHeight;
      const btn = clone.querySelector(".work-button");
      if (btn) h += btn.offsetHeight;
      document.body.removeChild(clone);
      return h;
    }
  </script>

  <!-- Автоматическая установка эффекта scramble для элементов внутри main и для обложки -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const mainEls = document.querySelectorAll('main *');
      mainEls.forEach(el => {
        const tag = el.tagName.toLowerCase();
        if (!['h1','h2','h3','button','a'].includes(tag) && !el.closest('.floating-quote') && el.children.length === 0 && el.textContent.trim().length > 0 && !el.classList.contains('scramble-text')) {
          el.classList.add('scramble-text');
          scrambleObserver.observe(el);
        }
      });
      const coverEls = document.querySelectorAll('#cover .cover-content p');
      coverEls.forEach(el => {
        if (!el.classList.contains('scramble-text')) {
          el.classList.add('scramble-text');
          scrambleObserver.observe(el);
        }
      });
    });
  </script>

  <!-- TextScramble с таймингом -->
  <script>
    class TextScramble {
      constructor(el) {
        this.el = el;
        this.chars = '!<>-_\\/[]{}—=+*^?#________';
        this.update = this.update.bind(this);
      }
      setText(newText) {
        cancelAnimationFrame(this.frameRequest);
        this.elapsed = 0;
        this.lastTime = null;
        this.queue = [];
        this.spans = [];
        this.el.textContent = "";
        for (let i = 0; i < newText.length; i++) {
          const span = document.createElement("span");
          this.el.appendChild(span);
          this.spans.push(span);
          const to = newText[i];
          const start = Math.random() * 200;
          const duration = Math.random() * 200 + 200;
          const end = start + duration;
          this.queue.push({ to, start, end, char: null });
        }
        return new Promise(resolve => {
          this.resolve = resolve;
          requestAnimationFrame(this.update);
        });
      }
      update(timestamp) {
        if (!this.lastTime) this.lastTime = timestamp;
        const delta = timestamp - this.lastTime;
        this.lastTime = timestamp;
        this.elapsed += delta;
        let complete = 0;
        for (let i = 0, n = this.queue.length; i < n; i++) {
          const { to, start, end } = this.queue[i];
          const span = this.spans[i];
          if (this.elapsed >= end) {
            complete++;
            span.textContent = to;
            span.classList.remove("dud");
          } else if (this.elapsed >= start) {
            if (!this.queue[i].char || Math.random() < 0.28) this.queue[i].char = this.randomChar();
            span.textContent = this.queue[i].char;
            span.classList.add("dud");
          } else {
            span.textContent = "";
          }
        }
        if (complete === this.queue.length) this.resolve();
        else this.frameRequest = requestAnimationFrame(this.update);
      }
      randomChar() {
        return this.chars[Math.floor(Math.random() * this.chars.length)];
      }
    }
    const scrambleObserver = new IntersectionObserver((entries, obs) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const el = entry.target;
          const original = el.getAttribute('data-text') || el.textContent;
          el.textContent = "";
          const fx = new TextScramble(el);
          fx.setText(original);
          obs.unobserve(el);
        }
      });
    }, { root: null, rootMargin: "0px 0px -10% 0px", threshold: 0.1 });
  </script>

  <!-- Наблюдатель для появления карточек портфолио (анимация и scramble) -->
  <script>
    const cardObserver = new IntersectionObserver((entries, obs) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const article = entry.target;
          article.style.height = measureCardHeight(article) + "px";
          article.classList.add('visible');
          setTimeout(() => {
            article.querySelectorAll('.scramble-text').forEach(el => scrambleObserver.observe(el));
          }, 700);
          obs.unobserve(article);
        }
      });
    }, { threshold: 0.1 });
  </script>

  <!-- Единый блок для Burger Menu -->
  <script>
    const burger = document.querySelector('.burger');
    const navLinks = document.querySelector('.nav-links');
    burger.addEventListener('click', () => {
      navLinks.style.display = (getComputedStyle(navLinks).display === 'none') ? 'flex' : 'none';
    });
  </script>

  <!-- Модальное окно -->
  <script>
    const modal = document.getElementById("modal");
    const modalTitleText = document.getElementById("modal-title-text");
    const modalMediaWrapper = document.getElementById("modal-media-wrapper");
    const modalClose = document.getElementById("modal-close");
    document.getElementById("portfolio-container").addEventListener("click", function (e) {
      let target = e.target;
      if (target.classList.contains("work-thumb")) {
        const article = target.closest(".work-item");
        let titleText = "";
        if (article) {
          const titleEl = article.querySelector("h3");
          if (titleEl) titleText = titleEl.textContent.trim();
        }
        modalTitleText.textContent = titleText || "Без названия";
        modalMediaWrapper.innerHTML = "";
        modal.style.display = "block";
        if (target.tagName.toLowerCase() === "img") {
          let img = document.createElement("img");
          img.src = target.src;
          img.className = "modal-media";
          modalMediaWrapper.appendChild(img);
        } else if (target.tagName.toLowerCase() === "video") {
          let video = document.createElement("video");
          const sourceEl = target.querySelector("source");
          video.src = sourceEl ? sourceEl.src : target.src;
          video.type = sourceEl ? sourceEl.type : "";
          video.controls = true;
          video.autoplay = true;
          video.playsInline = true;
          video.className = "modal-media";
          modalMediaWrapper.appendChild(video);
        }
      }
    });
    modalClose.addEventListener("click", () => {
      modal.style.display = "none";
      modalMediaWrapper.innerHTML = "";
      modalTitleText.textContent = "";
    });
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        modal.style.display = "none";
        modalMediaWrapper.innerHTML = "";
        modalTitleText.textContent = "";
      }
    });
  </script>

  <!-- Генерация карточек портфолио на основе JSON с ленивой подгрузкой -->
  <script>
    function sanitize(val) {
      return val ? val.toString().trim() : "";
    }
    document.addEventListener('DOMContentLoaded', () => {
      fetch("artportfolio.json")
        .then(response => response.json())
        .then(data => {
          const container = document.getElementById("portfolio-container");
          // Фильтруем пустые элементы
          const portfolioItems = data.filter(item => {
            return !Object.values(item).every(val => typeof val === "string" ? val.trim() === "" : !val);
          });
          // Создаём наблюдатель для ленивой загрузки карточек
          const lazyCardObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                const placeholder = entry.target;
                const index = placeholder.getAttribute("data-index");
                const item = portfolioItems[index];
                const article = document.createElement("article");
                article.className = "work-item";
                const media = document.createElement("div");
                media.className = "work-media";
                const mediaId = sanitize(item.mediaid);
                let mediaElement;
                if (mediaId) {
                  if (mediaId.includes(".")) {
                    const ext = mediaId.substring(mediaId.lastIndexOf(".")).toLowerCase();
                    if (ext === ".mp4" || ext === ".webm") {
                      mediaElement = document.createElement("video");
                      mediaElement.setAttribute("controls", "controls");
                      mediaElement.setAttribute("loading", "lazy");
                      mediaElement.setAttribute("decoding", "async");
                      mediaElement.classList.add("work-thumb");
                      let source = document.createElement("source");
                      source.src = "assets/" + mediaId;
                      source.type = ext === ".mp4" ? "video/mp4" : "video/webm";
                      mediaElement.appendChild(source);
                    } else {
                      let imageSrc = "assets/" + mediaId;
                      if (ext !== ".webp") {
                        imageSrc = imageSrc.replace(ext, ".webp");
                      }
                      mediaElement = document.createElement("img");
                      mediaElement.src = imageSrc;
                      mediaElement.alt = sanitize(item.title) || "Изображение работы";
                      mediaElement.className = "work-thumb";
                      mediaElement.setAttribute("loading", "lazy");
                      mediaElement.setAttribute("decoding", "async");
                    }
                  } else {
                    const webpURL = "assets/" + mediaId + ".webp";
                    mediaElement = document.createElement("img");
                    mediaElement.alt = sanitize(item.title) || "Изображение работы";
                    mediaElement.className = "work-thumb";
                    mediaElement.setAttribute("loading", "lazy");
                    mediaElement.setAttribute("decoding", "async");
                    let attempt = 0;
                    function tryNext() {
                      if (attempt >= 1) {
                        mediaElement.onerror = null;
                        mediaElement.src = "assets/logo.svg";
                        return;
                      }
                      attempt++;
                      mediaElement.src = webpURL;
                    }
                    mediaElement.onerror = tryNext;
                    mediaElement.onload = () => { mediaElement.onerror = null; };
                    tryNext();
                  }
                } else {
                  const placeholderDiv = document.createElement("div");
                  placeholderDiv.className = "placeholder-logo";
                  const placeholderImg = document.createElement("img");
                  placeholderImg.src = "assets/logo.svg";
                  placeholderImg.alt = "Placeholder";
                  placeholderDiv.appendChild(placeholderImg);
                  mediaElement = placeholderDiv;
                }
                media.appendChild(mediaElement);
                const details = document.createElement("div");
                details.className = "work-details";
                const h3 = document.createElement("h3");
                h3.textContent = sanitize(item.title) || "Без названия";
                const pYear = document.createElement("p");
                pYear.innerHTML = "Год: <span class='scramble-text' data-text='" + (sanitize(item.year) || "—") + "'>-</span>";
                const pDesc = document.createElement("p");
                pDesc.innerHTML = "Описание: <span class='scramble-text' data-text='" + (sanitize(item.description) || "") + "'>-</span>";
                const pMaterials = document.createElement("p");
                pMaterials.innerHTML = "Материалы: <span class='scramble-text' data-text='" + (sanitize(item.materials) || "—") + "'>-</span>";
                const pStatus = document.createElement("p");
                pStatus.innerHTML = "Статус: <span class='scramble-text' data-text='" + (sanitize(item.status) || "—") + "'>-</span>";
                details.appendChild(h3);
                details.appendChild(pYear);
                details.appendChild(pDesc);
                details.appendChild(pMaterials);
                details.appendChild(pStatus);
                const btnName = sanitize(item.btnname);
                const btnLink = sanitize(item.btnlink);
                if (btnName && btnLink) {
                  const btn = document.createElement("a");
                  btn.textContent = btnName;
                  btn.href = btnLink;
                  btn.className = "work-button";
                  btn.target = "_blank";
                  details.appendChild(btn);
                }
                article.appendChild(media);
                article.appendChild(details);
                // Заменяем placeholder на готовую карточку
                placeholder.replaceWith(article);
                cardObserver.observe(article);
                observer.unobserve(placeholder);
              }
            });
          }, { rootMargin: "200px 0px", threshold: 0.1 });
          
          // Создаём placeholder-ы для каждой карточки
          portfolioItems.forEach((item, index) => {
            const placeholder = document.createElement("div");
            placeholder.className = "work-item-placeholder";
            placeholder.setAttribute("data-index", index);
            container.appendChild(placeholder);
            lazyCardObserver.observe(placeholder);
          });
        })
        .catch(error => console.error("Error loading artportfolio.json:", error));
    });
  </script>

  <!-- Скрипт для плавающих цитат (интервал 8000 мс) -->
  <script>
    function spawnQuote() {
      if (!quotesArray.length) return;
      const q = quotesArray[Math.floor(Math.random() * quotesArray.length)];
      const div = document.createElement('div');
      div.className = 'floating-quote';
      div.innerHTML = `
        <span class="quote-text">${q.text}</span>
        <span class="quote-author">${q.author}</span>
      `;
      const docWidth = document.documentElement.scrollWidth;
      const docHeight = document.documentElement.scrollHeight;
      const x = 0.05 * docWidth + Math.random() * (0.9 * docWidth);
      const y = 0.1 * docHeight + Math.random() * (0.8 * docHeight);
      div.style.left = x + 'px';
      div.style.top = y + 'px';
      document.body.appendChild(div);
      setTimeout(() => { div.remove(); }, 10000);
    }
    let quotesArray = [];
    fetch("quote.json")
      .then(response => response.json())
      .then(data => { quotesArray = data; })
      .catch(error => console.error("Error loading quote.json:", error));
    setInterval(spawnQuote, 8000);
  </script>
</body>
</html>
