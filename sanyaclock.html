<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sanya Clock</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; height: 100%; }
    canvas { display: block; }
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255,255,255,0.8);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      line-height: 1.4;
    }
    #title {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 16px;
      background: rgba(255,255,255,0.8);
      padding: 5px 10px;
      border-radius: 5px;
      line-height: 1.4;
    }
    #timeLabel {
      position: absolute;
      top: 70px;
      left: 10px;
      font-size: 24px;
      background: rgba(255,255,255,0.8);
      padding: 5px 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <!-- Заголовок -->
  <div id="title">
    Калькулятор релятивистского искажения времени<br>
    вызванного Саня-полем
  </div>
  <!-- Надпись с вычисленным временем -->
  <div id="timeLabel">Саня придет в: --:--</div>
  <!-- Элементы управления -->
  <div id="controls">
    <div>
      <label for="distortionMagnitude">Величина искажения:</label>
      <input type="number" id="distortionMagnitude" value="0.2" step="0.01">
    </div>
    <div>
      <label for="growthCoefficient">Коэффициент роста:</label>
      <input type="number" id="growthCoefficient" value="0.5" step="0.01">
    </div>
    <div>
      <label for="einsteinFirsov">Коэффициент Энштейна‑Фирсова:</label>
      <input type="number" id="einsteinFirsov" value="1" step="0.01">
    </div>
    <div>
      <label for="temporalDensity">Плотность темпорального поля:</label>
      <input type="number" id="temporalDensity" value="1" step="0.01">
    </div>
  </div>
  <!-- Подключение Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Вспомогательная функция для корректного остатка по модулю (положительный результат)
    function mod(a, n) {
      return ((a % n) + n) % n;
    }
    
    /* Функция distort:
       x – исходный угол (в "часовом пространстве", где 0 = 12:00)
       aHand – угол часов (без искажений)
       aPin – базовый угол булавки (фиксируется при клике)
       F – коэффициент растяжения для участка от aHand до aPin.
       Функция растягивает участок между aHand и aPin (умножая угол на F) 
       и сжимает оставшуюся часть так, чтобы сумма осталась 2π.
    */
    function distort(x, aHand, aPin, F) {
      const full = 2 * Math.PI;
      let L1 = mod(aPin - aHand, full);
      let L2 = full - L1;
      let delta = mod(x - aHand, full);
      if (delta <= L1) {
        return mod(aHand + F * delta, full);
      } else {
        let K = (full - F * L1) / L2;
        return mod(aHand + F * L1 + K * (delta - L1), full);
      }
    }
    
    // Массивы для хранения данных тик-марок и цифровых меток
    const tickData = []; // { mesh, baseAngle, tickLength }
    const labelData = []; // { mesh, baseAngle }
    
    // Создаем сцену, камеру и рендерер на весь экран
    const scene = new THREE.Scene();
    const canvasWidth = window.innerWidth;
    const canvasHeight = window.innerHeight;
    const camera = new THREE.PerspectiveCamera(45, canvasWidth / canvasHeight, 0.1, 1000);
    camera.position.z = 12;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(canvasWidth, canvasHeight);
    renderer.setClearColor(0xaaaaaa);
    document.body.appendChild(renderer.domElement);
    
    // Вычисляем видимую высоту сцены и задаем радиус циферблата так, чтобы диаметр был 90% высоты
    const visibleHeight = 2 * camera.position.z * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
    const clockRadius = (visibleHeight * 0.9) / 2;
    
    // Функция для преобразования из "часового пространства" (0 = 12:00, по часовой стрелке)
    // в угол для Three.js (где 0 = ось X, вправо)
    function toSceneAngle(clockAngle) {
      return Math.PI / 2 - clockAngle;
    }
    
    // Создаем циферблат – белый круг
    const faceGeometry = new THREE.CircleGeometry(clockRadius, 144);
    const faceMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const clockFace = new THREE.Mesh(faceGeometry, faceMaterial);
    scene.add(clockFace);
    
    // Добавляем рамку (кольцо) вокруг циферблата
    const borderGeometry = new THREE.RingGeometry(clockRadius * 0.98, clockRadius * 1.02, 144);
    const borderMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
    const border = new THREE.Mesh(borderGeometry, borderMaterial);
    scene.add(border);
    
    // Создаем 144 тик-марки (каждая соответствует 5 минутам)
    const totalTicks = 144;
    for (let i = 0; i < totalTicks; i++) {
      const baseAngle = mod(i * (2 * Math.PI / totalTicks), 2 * Math.PI); // 0 = 12:00
      const isBig = (i % 12 === 0);
      const tickLength = isBig ? 0.5 : 0.25;
      const tickWidth = isBig ? 0.1 : 0.05;
      
      const geometry = new THREE.BoxGeometry(tickWidth, tickLength, 0.05);
      geometry.translate(0, tickLength / 2, 0);
      const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const tickMesh = new THREE.Mesh(geometry, material);
      scene.add(tickMesh);
      
      tickData.push({ mesh: tickMesh, baseAngle: baseAngle, tickLength: tickLength });
    }
    
    // Загружаем шрифт и создаем цифровые метки (для больших делений, каждые 12 тиков)
    const fontLoader = new THREE.FontLoader();
    fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
      for (let i = 0; i < totalTicks; i += 12) {
        const baseAngle = mod(i * (2 * Math.PI / totalTicks), 2 * Math.PI);
        let hour = i / 12;
        if (hour === 0) hour = 12;
        const textGeometry = new THREE.TextGeometry(hour.toString(), {
          font: font,
          size: 0.5,
          height: 0.1,
          curveSegments: 12,
        });
        const textMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
        scene.add(textMesh);
        labelData.push({ mesh: textMesh, baseAngle: baseAngle });
      }
    });
    
    // Создаем часовую стрелку (без искажений)
    function createHourHand() {
      const shape = new THREE.Shape();
      const baseWidth = 0.3;
      const handLength = clockRadius * 0.95; // почти до рамки
      const tipInset = 0.7;
      
      shape.moveTo(-baseWidth / 2, 0);
      shape.lineTo(baseWidth / 2, 0);
      shape.lineTo(baseWidth / 2, handLength - tipInset);
      shape.lineTo(0.15, handLength - tipInset / 2);
      shape.lineTo(0, handLength);
      shape.lineTo(-0.15, handLength - tipInset / 2);
      shape.lineTo(-baseWidth / 2, handLength - tipInset);
      shape.lineTo(-baseWidth / 2, 0);
      
      const extrudeSettings = { depth: 0.1, bevelEnabled: false };
      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
      return new THREE.Mesh(geometry, material);
    }
    
    const hourHand = createHourHand();
    scene.add(hourHand);
    
    // Переменные для работы с искажением:
    // aPinClock – исходный (базовый) угол булавки (в "часовом пространстве")
    // pinSetTime – время установки булавки (в мс)
    let aPinClock = null;
    let pinSetTime = null;
    
    // Переменная для текущего значения EF, которое изменяется с учетом плотности темпорального поля.
    let currentEF = 1;  // будет инициализировано при установке булавки
    
    // Красная булавка (создаётся по клику)
    let redPin = null;
    
    // Обновляем позиции тик-марок, цифровых меток и булавки с учетом дисторсии
    function updateScale(aHand, F) {
      tickData.forEach(data => {
        let newAngle = (aPinClock !== null) ? distort(data.baseAngle, aHand, aPinClock, F) : data.baseAngle;
        const sceneAngle = toSceneAngle(newAngle);
        const r = clockRadius - data.tickLength;
        data.mesh.position.x = Math.cos(sceneAngle) * r;
        data.mesh.position.y = Math.sin(sceneAngle) * r;
        data.mesh.rotation.z = -newAngle;
      });
      labelData.forEach(data => {
        let newAngle = (aPinClock !== null) ? distort(data.baseAngle, aHand, aPinClock, F) : data.baseAngle;
        const sceneAngle = toSceneAngle(newAngle);
        const r = clockRadius - 1;
        data.mesh.position.x = Math.cos(sceneAngle) * r;
        data.mesh.position.y = Math.sin(sceneAngle) * r;
      });
      if (redPin && aPinClock !== null) {
        const newAngle = distort(aPinClock, aHand, aPinClock, F);
        const sceneAngle = toSceneAngle(newAngle);
        redPin.position.x = Math.cos(sceneAngle) * clockRadius;
        redPin.position.y = Math.sin(sceneAngle) * clockRadius;
        let totalMinutes = (newAngle / (2 * Math.PI)) * 720;
        totalMinutes = Math.round(totalMinutes);
        let hoursPart = Math.floor(totalMinutes / 60);
        let minutesPart = totalMinutes % 60;
        if (hoursPart === 0) hoursPart = 12;
        document.getElementById('timeLabel').textContent = 'Саня придет в: ' + hoursPart + ':' + (minutesPart < 10 ? '0' : '') + minutesPart;
      }
    }
    
    // Для плавного обновления EF с учётом плотности темпорального поля
    let lastFrameTime = Date.now();
    
    // Анимация: обновление сцены
    function animate() {
      requestAnimationFrame(animate);
      const now = new Date();
      const totalMinutes = ((now.getHours() % 12) * 60) + now.getMinutes() + now.getSeconds()/60 + now.getMilliseconds()/60000;
      const aHand = (totalMinutes / 720) * 2 * Math.PI;
      hourHand.rotation.z = -aHand;
      
      let effectiveF = 1; 
      if (pinSetTime !== null) {
        const dt_total = (Date.now() - pinSetTime) / 1000;  // время с момента установки булавки
        const currentTime = Date.now();
        const dt_frame = (currentTime - lastFrameTime) / 1000;
        lastFrameTime = currentTime;
        // Считываем параметры из полей ввода
        const distortionMagnitude = parseFloat(document.getElementById("distortionMagnitude").value) || 0;
        const growthCoefficient = parseFloat(document.getElementById("growthCoefficient").value) || 0;
        const einsteinFirsov = parseFloat(document.getElementById("einsteinFirsov").value) || 1;
        const temporalDensity = parseFloat(document.getElementById("temporalDensity").value) || 1;
        // Если это первый кадр после установки, инициализируем currentEF
        if (currentEF === 1 && einsteinFirsov !== 1) {
          currentEF = einsteinFirsov;
        }
        // Обновляем currentEF с учетом плотности темпорального поля:
        currentEF += (temporalDensity - 1) * dt_frame;
        // Вычисляем эффективный коэффициент искажения:
        effectiveF = 1 + distortionMagnitude * dt_total * growthCoefficient * currentEF;
      }
      
      updateScale(aHand, effectiveF);
      renderer.render(scene, camera);
    }
    
    animate();
    
    // Обработчик клика – установка булавки и фиксация её базового угла
    function onMouseClick(event) {
      const mouse = new THREE.Vector2();
      mouse.x = (event.clientX / canvasWidth) * 2 - 1;
      mouse.y = - (event.clientY / canvasHeight) * 2 + 1;
      
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
      const clickPoint = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, clickPoint);
      if (clickPoint.length() < 0.1) return;
      
      const pinPos = clickPoint.clone().setLength(clockRadius);
      // Вычисляем угол в сценическом пространстве и преобразуем его в "часовой" угол
      const sceneAngle = Math.atan2(pinPos.y, pinPos.x);
      aPinClock = mod(Math.PI / 2 - sceneAngle, 2 * Math.PI);
      pinSetTime = Date.now();
      // Инициализируем currentEF из поля ввода "Коэффициент Энштейна‑Фирсова"
      currentEF = parseFloat(document.getElementById("einsteinFirsov").value) || 1;
      
      if (!redPin) {
        const pinGeometry = new THREE.SphereGeometry(0.15, 16, 16);
        const pinMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        redPin = new THREE.Mesh(pinGeometry, pinMaterial);
        scene.add(redPin);
      }
    }
    
    renderer.domElement.addEventListener('click', onMouseClick, false);
    
    window.addEventListener('resize', () => {
      const newCanvasWidth = window.innerWidth;
      const newCanvasHeight = window.innerHeight;
      camera.aspect = newCanvasWidth / newCanvasHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(newCanvasWidth, newCanvasHeight);
    });
  </script>
</body>
</html>
